# Terraform for PostgreSQL Infrastructure

This section of the project provides Terraform configurations to provision PostgreSQL instances on various cloud providers. The goal is to create a repeatable and version-controlled infrastructure setup that can then be managed by the Ansible playbooks in the parent project.

## Structure

Each cloud provider has its own subdirectory under `terraform/` which serves as a root template for new projects. Each template includes a `terraform.tfvars.example` file that should be copied to `terraform.tfvars` and customized.

```
terraform/
├── aws/                  # Root template for AWS Terraform projects
│   ├── main.tf           # Main Terraform configuration for AWS
│   ├── variables.tf      # Input variables for AWS
│   ├── outputs.tf        # Outputs for AWS (e.g., DB endpoint)
│   ├── terraform.tfvars.example # Example variables for AWS
│   └── .gitignore        # Terraform specific gitignore
├── azure/                # Root template for Azure Terraform projects
│   ├── main.tf           # Main Terraform configuration for Azure
│   ├── variables.tf      # Input variables for Azure
│   ├── outputs.tf        # Outputs for Azure
│   ├── terraform.tfvars.example # Example variables for Azure
│   └── .gitignore        # Terraform specific gitignore
└── README.md             # This file
```

## General Workflow

1.  **Copy a Cloud Provider Template**: When starting a new infrastructure project for a specific cloud, copy the relevant template directory (e.g., `terraform/aws/`) to a new project-specific location, for example, `projects/<your_ansible_project_name>/terraform/aws/`.
    ```sh
    # Example for an Ansible project named 'myclient_db_project' needing AWS infra
    mkdir -p projects/myclient_db_project/terraform
    cp -r terraform/aws/ projects/myclient_db_project/terraform/aws
    cd projects/myclient_db_project/terraform/aws
    ```

2.  **Customize Variables**:
    *   Copy `terraform.tfvars.example` to `terraform.tfvars` within your new project's Terraform directory (e.g., `projects/myclient_db_project/terraform/aws/terraform.tfvars`).
    *   **Important:** Add `terraform.tfvars` to your project-specific `.gitignore` file if it's not already covered by a global rule, as it may contain sensitive information.
    *   Modify the `terraform.tfvars` file to provide specific values for your deployment (e.g., instance sizes, region, resource names, VPC details, passwords).
    *   Review `variables.tf` in the template directory for available options and their descriptions.

3.  **Initialize Terraform** (in your project's Terraform directory, e.g., `projects/myclient_db_project/terraform/aws`):
    ```sh
    terraform init
    ```

4.  **Plan and Apply**:
    ```sh
    terraform plan -out=tfplan
    terraform apply tfplan
    ```

5.  **Use Outputs**: The `outputs.tf` will define important information like the database endpoint, port, and any generated IDs. This information will be crucial for configuring your Ansible inventory (`projects/<your_ansible_project_name>/inventory/hosts`) to manage the provisioned PostgreSQL instance.

## AWS Specifics (`terraform/aws/`)

The `terraform/aws/` template provides a comprehensive solution for provisioning an AWS RDS PostgreSQL instance.

**Key Features:**
*   **Conditional VPC Creation**:
    *   Set `create_vpc = true` (default) in your `terraform.tfvars` to provision a new VPC, public and private subnets, an Internet Gateway, route tables, a DB subnet group, and an RDS security group.
    *   Set `create_vpc = false` to use existing VPC resources. In this case, you must provide `db_subnet_group_name` (or `private_subnet_ids_for_db_group` to create a new subnet group from existing subnets) and `vpc_security_group_ids`.
*   **RDS Instance**: Provisions an `aws_rds_instance` with configurable parameters for instance class, storage, engine version, etc.
*   **Password Management**:
    *   If `db_password_override` is set in `terraform.tfvars`, that password will be used.
    *   Otherwise, a random password will be generated by the `random_password` resource.
*   **Outputs**: Includes RDS endpoint, port, generated password (if applicable), and DB subnet group name.

**Example `terraform.tfvars` for AWS:**
Refer to `terraform/aws/terraform.tfvars.example` for a detailed example. Customize it by copying to `terraform.tfvars` in your project directory.

## Azure Specifics (`terraform/azure/`)

The `terraform/azure/` template provisions an Azure Database for PostgreSQL Flexible Server.

**Key Features:**
*   **Resource Group**: Creates or uses an existing Azure Resource Group.
*   **Flexible Server**: Provisions an `azurerm_postgresql_flexible_server` with configurable SKU, storage, version, etc.
*   **Password Management**:
    *   If `pg_admin_password_override` is set, that password will be used.
    *   Otherwise, a random password will be generated.
*   **Networking**:
    *   Supports enabling/disabling public network access.
    *   Allows configuration of firewall rules for specific IPs or Azure services.
    *   For production, VNet integration is recommended (example commented out in `main.tf`).
*   **Outputs**: Includes server FQDN, admin login, and generated password (if applicable).

**Example `terraform.tfvars` for Azure:**
Refer to `terraform/azure/terraform.tfvars.example`. Customize it by copying to `terraform.tfvars` in your project directory.

## Integrating with Ansible

After successfully provisioning your PostgreSQL instance with Terraform:
1.  Retrieve the necessary connection details from Terraform outputs (e.g., DB endpoint/hostname, port).
2.  Update your Ansible inventory file (`projects/<your_ansible_project_name>/inventory/hosts`) with this information.
    *   Set `ansible_host` to the Terraform output DB endpoint/FQDN.
    *   Set `db_type: managed`.
    *   Set `ansible_connection: local` (as Ansible will connect to the DB directly, not SSH to a host managing it).
3.  Update your Ansible group variables (`vars.yml` and `vault.yml`) with database names, admin usernames, and passwords. The admin password should match the one set or generated during Terraform provisioning.
4.  You can then use the Ansible playbooks (e.g., `playbooks/manage.yml`) to perform further database configuration, schema creation, user management, etc., on the Terraform-provisioned instance.

This approach separates infrastructure provisioning (Terraform) from configuration management (Ansible), allowing for a clean and modular setup.
